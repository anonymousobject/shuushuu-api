"""
Tag Suggestions API Endpoints

Provides endpoints for viewing and managing ML-generated tag suggestions.
"""

from datetime import UTC, datetime
from typing import Annotated, Literal

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy import desc, func, select
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.auth import CurrentUser
from app.core.database import get_db
from app.core.permissions import Permission, has_permission
from app.models.image import Images
from app.models.tag import Tags
from app.models.tag_link import TagLinks
from app.models.tag_suggestion import TagSuggestion
from app.schemas.tag import TagResponse
from app.schemas.tag_suggestion import (
    GenerateSuggestionsResponse,
    ReviewSuggestionsRequest,
    ReviewSuggestionsResponse,
    TagSuggestionResponse,
    TagSuggestionsListResponse,
)
from app.tasks.queue import enqueue_job

router = APIRouter(prefix="/images", tags=["tag-suggestions"])


@router.get(
    "/{image_id}/tag-suggestions",
    response_model=TagSuggestionsListResponse,
    response_description="List of tag suggestions with status counts",
)
async def get_tag_suggestions(
    image_id: int,
    status_filter: Annotated[
        Literal["pending", "approved", "rejected"] | None,
        Query(alias="status", description="Filter by suggestion status"),
    ] = None,
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = ...,  # type: ignore[assignment]
) -> TagSuggestionsListResponse:
    """
    Get ML-generated tag suggestions for an image.

    This endpoint returns tag suggestions that were automatically generated by machine learning
    models when the image was uploaded. Suggestions can be filtered by their review status.

    **Permissions:**
    - Image uploader can view suggestions for their own images
    - Moderators with IMAGE_TAG_ADD permission can view suggestions for all images

    **Workflow:**
    1. ML models analyze the image during upload (background job)
    2. Tag suggestions are stored with confidence scores
    3. User/moderator reviews suggestions via this endpoint
    4. Approved suggestions create TagLinks (applied to image)

    **Examples:**

    Get all pending suggestions:
    ```
    GET /api/v1/images/12345/tag-suggestions?status=pending
    ```

    Get all suggestions (any status):
    ```
    GET / api / v1 / images / 12345 / tag - suggestions
    ```

    **Response includes:**
    - List of suggestions with tag details and confidence scores
    - Count of suggestions by status (pending/approved/rejected)
    - Model source (custom_theme or danbooru)

    Args:
        image_id: ID of the image
        status_filter: Optional filter by status (pending/approved/rejected)
        db: Database session
        current_user: Current authenticated user

    Returns:
        List of tag suggestions with counts by status

    Raises:
        HTTPException: 404 if image not found, 403 if permission denied
    """
    # Check if image exists
    image_result = await db.execute(
        select(Images).where(Images.image_id == image_id)  # type: ignore[arg-type]
    )
    image = image_result.scalar_one_or_none()
    if not image:
        raise HTTPException(status_code=404, detail="Image not found")

    # Check permissions: owner or moderator
    is_owner = image.user_id == current_user.user_id
    is_moderator = await has_permission(
        db,
        current_user.user_id,  # type: ignore[arg-type]
        Permission.IMAGE_TAG_ADD,
    )

    if not is_owner and not is_moderator:
        raise HTTPException(
            status_code=403,
            detail="You can only view suggestions for your own images",
        )

    # Build query for suggestions
    query = select(TagSuggestion).where(
        TagSuggestion.image_id == image_id  # type: ignore[arg-type]
    )
    if status_filter:
        query = query.where(TagSuggestion.status == status_filter)  # type: ignore[arg-type]

    suggestions_result = await db.execute(
        query.order_by(desc(TagSuggestion.confidence))  # type: ignore[arg-type]
    )
    suggestions = list(suggestions_result.scalars().all())

    # Batch fetch all tags in one query to avoid N+1 problem
    tag_ids = [sugg.tag_id for sugg in suggestions]
    tag_result = await db.execute(
        select(Tags).where(Tags.tag_id.in_(tag_ids))  # type: ignore[union-attr]
    )
    tags_by_id = {tag.tag_id: tag for tag in tag_result.scalars().all()}

    # Build suggestion responses
    suggestion_responses = [
        TagSuggestionResponse(
            suggestion_id=sugg.suggestion_id,  # type: ignore[arg-type]
            tag=TagResponse.model_validate(tags_by_id[sugg.tag_id]),
            confidence=sugg.confidence,
            model_source=sugg.model_source,  # type: ignore[arg-type]
            status=sugg.status,  # type: ignore[arg-type]
            created_at=sugg.created_at,
            reviewed_at=sugg.reviewed_at,
        )
        for sugg in suggestions
    ]

    # Count by status (for all suggestions, not just filtered ones)
    status_counts_result = await db.execute(
        select(TagSuggestion.status, func.count(TagSuggestion.suggestion_id))  # type: ignore[call-overload, arg-type]
        .where(TagSuggestion.image_id == image_id)
        .group_by(TagSuggestion.status)
    )

    counts = {"pending": 0, "approved": 0, "rejected": 0}
    for status_val, count in status_counts_result:
        counts[status_val] = count

    return TagSuggestionsListResponse(
        image_id=image_id,
        suggestions=suggestion_responses,
        total=len(suggestion_responses),
        pending=counts["pending"],
        approved=counts["approved"],
        rejected=counts["rejected"],
    )


@router.post(
    "/{image_id}/tag-suggestions/review",
    response_model=ReviewSuggestionsResponse,
    response_description="Review results with approval/rejection counts",
)
async def review_tag_suggestions(
    image_id: int,
    request: ReviewSuggestionsRequest,
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = ...,  # type: ignore[assignment]
) -> ReviewSuggestionsResponse:
    """
    Approve or reject tag suggestions in batch.

    This endpoint allows users to review ML-generated tag suggestions. Approving a suggestion
    applies the tag to the image (creates a TagLink), while rejecting marks it as reviewed
    but does not apply the tag.

    **Permissions:**
    - Image uploader can review suggestions for their own images
    - Moderators with IMAGE_TAG_ADD permission can review suggestions for all images

    **Behavior:**
    - **Approve**: Creates TagLink (applies tag to image) and marks suggestion as approved
    - **Reject**: Marks suggestion as rejected (does not apply tag)
    - Idempotent: Can re-review already reviewed suggestions
    - Prevents duplicate TagLinks (if tag already applied)
    - Tracks reviewer and review timestamp

    **Examples:**

    Approve some suggestions, reject others:
    ```json
    POST /api/v1/images/12345/tag-suggestions/review
    {
      "suggestions": [
        {"suggestion_id": 1, "action": "approve"},
        {"suggestion_id": 2, "action": "approve"},
        {"suggestion_id": 3, "action": "reject"}
      ]
    }
    ```

    Response:
    ```json
    {
      "approved": 2,
      "rejected": 1,
      "errors": []
    }
    ```

    **Workflow:**
    1. User views suggestions via GET endpoint
    2. User selects suggestions to approve/reject
    3. Sends batch review request
    4. Approved tags are immediately applied to image
    5. User can add additional tags manually if needed

    Args:
        image_id: ID of the image
        request: Batch of suggestion reviews (approve/reject actions)
        db: Database session
        current_user: Current authenticated user

    Returns:
        Counts of approved/rejected suggestions and any errors

    Raises:
        HTTPException: 404 if image not found, 403 if permission denied
    """
    # Check if image exists
    image_result = await db.execute(
        select(Images).where(Images.image_id == image_id)  # type: ignore[arg-type]
    )
    image = image_result.scalar_one_or_none()
    if not image:
        raise HTTPException(status_code=404, detail="Image not found")

    # Check permissions: owner or moderator
    is_owner = image.user_id == current_user.user_id
    is_moderator = await has_permission(
        db,
        current_user.user_id,  # type: ignore[arg-type]
        Permission.IMAGE_TAG_ADD,
    )

    if not is_owner and not is_moderator:
        raise HTTPException(
            status_code=403,
            detail="You can only review suggestions for your own images",
        )

    # Batch fetch all suggestions in one query to avoid N+1
    suggestion_ids = [item.suggestion_id for item in request.suggestions]
    suggestions_result = await db.execute(
        select(TagSuggestion).where(
            TagSuggestion.suggestion_id.in_(suggestion_ids),  # type: ignore[union-attr]
            TagSuggestion.image_id == image_id,  # type: ignore[arg-type]
        )
    )
    suggestions_by_id = {sugg.suggestion_id: sugg for sugg in suggestions_result.scalars().all()}

    # Batch fetch existing TagLinks to avoid creating duplicates
    tag_ids = [sugg.tag_id for sugg in suggestions_by_id.values()]
    links_result = await db.execute(
        select(TagLinks).where(
            TagLinks.image_id == image_id,  # type: ignore[arg-type]
            TagLinks.tag_id.in_(tag_ids),  # type: ignore[attr-defined]
        )
    )
    existing_links = {(link.image_id, link.tag_id) for link in links_result.scalars().all()}

    approved_count = 0
    rejected_count = 0
    errors: list[str] = []

    review_time = datetime.now(UTC)

    for review_item in request.suggestions:
        # Check if suggestion exists and belongs to this image
        suggestion = suggestions_by_id.get(review_item.suggestion_id)
        if not suggestion:
            errors.append(f"Suggestion {review_item.suggestion_id} not found")
            continue

        if review_item.action == "approve":
            # Create TagLink if it doesn't exist
            if (image_id, suggestion.tag_id) not in existing_links:
                tag_link = TagLinks(
                    image_id=image_id,
                    tag_id=suggestion.tag_id,
                    user_id=current_user.user_id,
                )
                db.add(tag_link)
                existing_links.add((image_id, suggestion.tag_id))

            # Update suggestion status
            suggestion.status = "approved"
            suggestion.reviewed_at = review_time
            suggestion.reviewed_by_user_id = current_user.user_id
            approved_count += 1

        elif review_item.action == "reject":
            # Update suggestion status only (no TagLink)
            suggestion.status = "rejected"
            suggestion.reviewed_at = review_time
            suggestion.reviewed_by_user_id = current_user.user_id
            rejected_count += 1

    await db.commit()

    return ReviewSuggestionsResponse(
        approved=approved_count,
        rejected=rejected_count,
        errors=errors,
    )


@router.post(
    "/{image_id}/tag-suggestions/generate",
    response_model=GenerateSuggestionsResponse,
    status_code=status.HTTP_202_ACCEPTED,
    response_description="Tag suggestion generation job queued",
)
async def generate_tag_suggestions(
    image_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = ...,  # type: ignore[assignment]
) -> GenerateSuggestionsResponse:
    """
    Trigger ML tag suggestion generation for an existing image.

    This endpoint queues a background job to analyze the image using ML models
    and generate tag suggestions. Use this for images uploaded before the tag
    suggestion system was implemented, or to regenerate suggestions.

    **Permissions:**
    - Image uploader can trigger generation for their own images
    - Users with IMAGE_TAG_ADD permission can trigger for any image

    **Behavior:**
    - Queues a background job (does not block)
    - New suggestions are created with 'pending' status
    - Existing suggestions are NOT deleted (idempotent)
    - Tags already applied to the image are skipped

    **Example:**
    ```
    POST / api / v1 / images / 12345 / tag - suggestions / generate
    ```

    **Response:**
    ```json
    {
      "message": "Tag suggestion generation queued",
      "image_id": 12345,
      "job_id": "arq:generate-12345"
    }
    ```

    Args:
        image_id: ID of the image
        db: Database session
        current_user: Current authenticated user

    Returns:
        Confirmation with job ID for tracking

    Raises:
        HTTPException: 404 if image not found, 403 if permission denied
    """
    # Check if image exists
    image_result = await db.execute(
        select(Images).where(Images.image_id == image_id)  # type: ignore[arg-type]
    )
    image = image_result.scalar_one_or_none()
    if not image:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Image not found")

    # Check permissions: owner or moderator with IMAGE_TAG_ADD
    is_owner = image.user_id == current_user.user_id
    is_moderator = await has_permission(
        db,
        current_user.user_id,  # type: ignore[arg-type]
        Permission.IMAGE_TAG_ADD,
    )

    if not is_owner and not is_moderator:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only generate suggestions for your own images",
        )

    # Enqueue the background job
    job_id = await enqueue_job("generate_tag_suggestions", image_id=image_id)

    return GenerateSuggestionsResponse(
        message="Tag suggestion generation queued",
        image_id=image_id,
        job_id=job_id,
    )

{"body":"The pagination logic is incorrect when report_type='all'. The same offset and limit are being applied to both image reports and comment reports separately, which means:\n\n1. When fetching both types with report_type='all', you could get up to 2*per_page items (per_page image reports + per_page comment reports)\n2. The total count is the sum of both report types, but pagination doesn't work correctly across the unified list\n\nFor example, if there are 15 image reports and 15 comment reports, requesting page=1 with per_page=20 should return a mix of the 20 most recent reports (combined), but the current implementation would return up to 40 items (20 from each type).\n\nThe pagination should either:\n- Apply to the unified result set (interleave and paginate combined results by created_at)\n- Keep separate pagination for each type and document this behavior clearly\n- Only allow fetching one report type at a time when paginating","line":1018,"path":"app/api/v1/admin.py"}
{"body":"The image_id field in CommentReportResponse uses a fallback of 0 when comment.image_id is None, but 0 is not a valid image_id (image IDs are positive integers in the database). This could cause confusion for API consumers.\n\nSince image_id is optional on comments (comments can exist without being associated with an image), the response schema should properly handle None/null values instead of defaulting to 0. Consider either:\n1. Making image_id optional in CommentReportResponse (int | None)\n2. Documenting that 0 means \"no associated image\"\n3. Ensuring all comments in the system have an associated image_id if this is a business requirement","line":null,"path":"app/api/v1/comments.py"}
{"body":"The query to fetch comment reports performs an INNER JOIN with the Comments table without any handling for deleted comments. If a comment is deleted after being reported (either through the report system or by other means), the query may fail or produce unexpected results:\n\n1. If the comment is soft-deleted (deleted=True), the join will still succeed but the admin won't know the comment is deleted\n2. If the comment is hard-deleted (CASCADE from foreign key), the report would be deleted too, but this conflicts with keeping a report history\n\nConsider:\n1. Adding a LEFT JOIN instead of INNER JOIN to handle cases where comments might be deleted\n2. Including the comment's deleted status in the response so admins know if the comment is already deleted\n3. Adding error handling for cases where the join fails\n```suggestion\n                Comments.deleted.label(\"comment_deleted\"),  # type: ignore[attr-defined]\n            )\n            .join(Users, Users.user_id == CommentReports.user_id)\n            .join(Comments, Comments.post_id == CommentReports.comment_id, isouter=True)\n```","line":null,"path":"app/api/v1/admin.py"}
{"body":"The category filter is not applied to comment reports. When fetching comment reports (lines 924-927), the query only filters by status_filter, but ignores the category parameter entirely. This is inconsistent with image report filtering (lines 862-866) where category is applied.\n\nWhile comment reports and image reports have different category systems (CommentReportCategory vs ReportCategory), the category parameter should either:\n1. Be applied to comment reports when report_type='comment'\n2. Be documented that category filtering only works for image reports\n3. Raise a validation error if category is specified for comment reports\n\nThis inconsistency could confuse API consumers expecting category filtering to work across both report types.","line":934,"path":"app/api/v1/admin.py"}
{"body":"The test assertion uses `\u003e= 1` instead of checking for an exact count. This could mask issues where the endpoint returns more reports than expected or where there's test data leakage between tests.\n\nConsider changing the assertion to check for exact equality to ensure better test isolation and catch potential bugs where the endpoint returns unexpected data.","line":null,"path":"tests/api/v1/test_comment_reports.py"}
{"body":"In the comment reports listing query, image_id is fetched from the Comments table (line 941), but since image_id can be null on comments, the response should handle this case. The CommentReportListItem is constructed with this potentially null image_id (line 982) but the schema defines image_id as a required int field (not optional).\n\nThis could cause validation errors when comments don't have an associated image. The schema should either:\n1. Make image_id optional (int | None) in CommentReportResponse\n2. Ensure the query excludes reports for comments without images\n3. Provide a default value like 0 (though this has the same semantic issue mentioned in a previous comment)","line":996,"path":"app/api/v1/admin.py"}
{"body":"The query uses INNER JOINs for both Users (reporter) and Comments tables. If a user who created a report is deleted (CASCADE), the report would also be deleted due to the foreign key constraint. However, if a comment is deleted after being reported:\n\n1. For soft-deletes (deleted=True), the report will still exist but the admin won't be able to see that the comment is already deleted in the listing\n2. For hard-deletes (if implemented), the CASCADE would delete the report too\n\nThe listing should include the comment's deleted status so admins can see which reports are for already-deleted comments, allowing them to quickly dismiss those reports.\n```suggestion\n                Comments.deleted.label(\"comment_deleted\"),  # type: ignore[attr-defined]\n            )\n            .join(Users, Users.user_id == CommentReports.user_id)\n            .outerjoin(Comments, Comments.post_id == CommentReports.comment_id)\n```","line":null,"path":"app/api/v1/admin.py"}
{"body":"The delete_comment_via_report endpoint uses AdminActionType.REPORT_ACTION for audit logging, but there's a more specific AdminActionType.COMMENT_DELETE constant available that would be more semantically correct for this action.\n\nUsing COMMENT_DELETE would make it easier to filter audit logs specifically for comment deletions, separate from other report actions. Consider changing line 1112 to use AdminActionType.COMMENT_DELETE instead.\n```suggestion\n        action_type=AdminActionType.COMMENT_DELETE,\n```","line":null,"path":"app/api/v1/admin.py"}
{"body":"There's no test coverage for the unified report listing with report_type='all', which is the default behavior. Tests should verify that:\n\n1. When report_type='all' (or omitted), both image and comment reports are returned\n2. The pagination behavior works correctly with the unified listing\n3. The total count includes both report types\n4. The response structure matches UnifiedReportListResponse\n\nThis is particularly important given the pagination issues identified in the implementation.","line":null,"path":"tests/api/v1/test_comment_reports.py"}
{"body":"When report_type is \"all\", pagination is applied separately to both image_reports and comment_reports queries, each fetching up to per_page items. This means the unified response could return up to (2 * per_page) items total instead of per_page items. The total count is also the sum of both types, which doesn't properly support unified pagination. Consider either:\n1. Implementing proper unified pagination where the combined result is limited to per_page items\n2. Documenting this behavior clearly in the API docstring\n3. Restricting \"all\" to only work without pagination, or with separate cursors for each type","line":1018,"path":"app/api/v1/admin.py"}
{"body":"The ReportActionType class is defined but never imported or used in the codebase. Consider removing it if it's not needed for this feature, or document that it's reserved for future enhancements.","line":330,"path":"app/config.py"}
{"body":"CommentReportListResponse is defined but never used. The API uses UnifiedReportListResponse instead. Consider removing this schema if it's not needed, or document if it's reserved for future standalone comment report listing endpoint.","line":85,"path":"app/schemas/comment_report.py"}
{"body":"When deleting a comment via report, child comments (replies) are not detached. The standard DELETE /comments/{comment_id} endpoint includes logic to set parent_comment_id=NULL for all child comments when the parent is deleted. This endpoint should include the same logic to maintain data consistency and prevent orphaned comment relationships.","line":1112,"path":"app/api/v1/admin.py"}
{"body":"There's a potential race condition in the report_comment endpoint. The check for existing pending reports (lines 619-630) and the creation of a new report (lines 633-642) are not atomic. Two concurrent requests from the same user for the same comment could both pass the check and both create reports. Consider adding a unique constraint on (comment_id, user_id, status) where status=PENDING, or handling the IntegrityError if a duplicate is inserted.","line":642,"path":"app/api/v1/comments.py"}
